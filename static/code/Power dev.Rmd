---
title: "Power analysis for mixed effects models"
author: "Douglas Luke"
date: "April 21, 2019"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: false
    theme: lumen
    highlight: textmate
urlcolor: blue
---

Code for testing and possibly adding to the Sage book on power analysis in multilevel models

## Setup

```{r}
library(simr)
library(lme4)
library(plyr)
library(dplyr)
library(purrr)
library(ggplot2)
library(scales)
```

## Create working dataset

```{r}
library(LukeMLM)
data(tvprp)
```

Working model for full dataset.

```{r}
modp_full <- lmer(votepct ~ pactotal*acres + (1|state),data=tvprp,REML=TRUE)
summary(modp_full)
```

Power for the three fixed effects.

```{r}
pwr_L1 <- powerSim(modp_full, fixed("pactotal",method="kr"),nsim=100)
print(pwr_L1)
pwr_L2 <- powerSim(modp_full, fixed("acres",method="kr"),nsim=100)
print(pwr_L2)
pwr_CLI <- powerSim(modp_full, fixed("pactotal:acres",method="kr"),nsim=100)
print(pwr_CLI)

```

Creating a data subset.

```{r}
tvsub <- tvprp[tvprp$state %in% c("TN","AL","MO","MN","MD"),]

tvsubtest <- tvsub %>% 
  mutate(stnum = as.numeric(factor(as.character(state))))

# str(tvsubtest)

```

Sub model and power.

```{r}
modp_sub <- lmer(votepct ~ pactotal*acres + (1|stnum),data=tvsubtest,REML=TRUE)
summary(modp_sub)
```

```{r}
pwr_L1 <- powerSim(modp_sub, fixed("pactotal",method="kr"),nsim=100)
pwr_L2 <- powerSim(modp_sub, fixed("acres",method="kr"),nsim=100)
pwr_CLI <- powerSim(modp_sub, fixed("pactotal:acres",method="kr"),nsim=100)
pwr_L1
pwr_L2
pwr_CLI

```
##

Trying to match power with powerSim. Using numbers from above dataset (tvsub)
and model (modp_sub). So, 5 states, each with about 10 people in each state. 

Code based on Arend (2019).

None of these results match up with the empirical (post-hoc) power
based on tvsub. Need to look at this more closely, think I'm not
understanding Table 3 in Arend yet.

```{r}
alpha.S <- .05
Size.clus <- 10
N.clus <- 5

intcpt <- .444
L1 <- .0094
L2 <- .0034
CLI <- -.000122

b <- c(intcpt,L1,L2,CLI)

# See below
L1_std <- .246
L2_var <- .0118

x <- (rep(1:Size.clus))
g <- as.factor(1:N.clus)
X <- cbind(expand.grid("x" = x, "g" = g))
X <- data.frame(X,Z = as.numeric(X$g))
# X$Z <- scale(X$Z)

```

```{r}
#Varcorr is variance, sigma is std. dev
model <- makeLmer(y ~ x + Z + x:Z + (1 | g),
                  fixef = b, VarCorr = L2_var, sigma = L1_std,
                  data = X)
print(model)
```

Power for three fixed effects.

```{r}
sim_L1 <- powerSim(model, fixed("x",method="kr"), alpha = alpha.S, nsim=100)
sim_L2 <- powerSim(model, fixed("Z",method="kr"), alpha = alpha.S, nsim=100)
sim_CLI <- powerSim(model, fixed("x:Z",method="kr"), alpha = alpha.S, nsim=100)
sim_L1
sim_L2
sim_CLI

```

So now just try adjusting the sample sizes directly for the empirical model.
This works nicely for number of states.

```{r}
modp_sub_ext <- extend(modp_sub, along="stnum", n=50)
modp_sub_ext
```

```{r}
pwr_L1ext <- powerSim(modp_sub_ext, fixed("pactotal",method="kr"),nsim=100)
pwr_L2ext <- powerSim(modp_sub_ext, fixed("acres",method="kr"),nsim=100)
pwr_CLIext <- powerSim(modp_sub_ext, fixed("pactotal:acres",method="kr"),nsim=100)
pwr_L1ext
pwr_L2ext
pwr_CLIext
```

```{r}
p_curve_acres <- powerCurve(modp_sub_ext, test=fixed("acres",method="kr"),nsim=100,along="stnum")
plot(p_curve_acres)
p_curve_CLI <- powerCurve(modp_sub_ext, test=fixed("pactotal:acres",method="kr"),nsim=100,along="stnum")
plot(p_curve_CLI)

```

Now increase the number of representatives per state.

```{r}
modp_sub_ext2 <- extend(modp_sub, within="stnum", n=20)
modp_sub_ext2
```

```{r}
pwr_L1ext <- powerSim(modp_sub_ext2, fixed("pactotal",method="kr"),nsim=100)
pwr_L2ext <- powerSim(modp_sub_ext2, fixed("acres",method="kr"),nsim=100)
pwr_CLIext <- powerSim(modp_sub_ext2, fixed("pactotal:acres",method="kr"),nsim=100)
pwr_L1ext
pwr_L2ext
pwr_CLIext
```

```{r}
p_curve_acres <- powerCurve(modp_sub_ext2, test=fixed("acres",method="kr"),nsim=100,within="stnum")
plot(p_curve_acres)
p_curve_CLI <- powerCurve(modp_sub_ext2, test=fixed("pactotal:acres",method="kr"),nsim=100,within="stnum")
plot(p_curve_CLI)

```

This also looks fine.

The last step is to show power when you change both number of states and number of people in state.
Not sure best way to graph this, but here are the power calculations with 15 people in 10 states.
Notice that you extend the model successively.

```{r}
modp_sub_ext3 <- extend(modp_sub, along="stnum", n=10)
modp_sub_ext3 <- extend(modp_sub_ext3, within="stnum", n=15)

modp_sub_ext3
```

```{r}
pwr_L1ext <- powerSim(modp_sub_ext3, fixed("pactotal",method="kr"),nsim=100)
pwr_L2ext <- powerSim(modp_sub_ext3, fixed("acres",method="kr"),nsim=100)
pwr_CLIext <- powerSim(modp_sub_ext3, fixed("pactotal:acres",method="kr"),nsim=100)
pwr_L1ext
pwr_L2ext
pwr_CLIext
```

## Putting it all together

Repeating some code from above.

Model with full dataset.

```{r}
modp_full <- lmer(votepct ~ pactotal*acres + (1|state),data=tvprp,REML=TRUE)
summary(modp_full)
```


```{r}
set.seed(2413)
tvsub <- tvprp %>% 
  filter(state %in% c("TN","AL","MO","MN","MD")) %>%
  mutate(stnum = as.numeric(factor(as.character(state)))) %>%
  group_by(stnum) %>%
  sample_n(5)

modp_sub <- lmer(votepct ~ pactotal*acres + (1|stnum),data=tvsub,REML=TRUE)
summary(modp_sub)
```



## Increasing groups

The functions

```{r}
mgrp_sim_L1 <- function(groups){

# Assumes lmer object is available  
if (groups == 5)
  {mod_ext <- modp_sub}
else 
  {mod_ext <- extend(modp_sub, along="stnum", n=groups)}
  
pwr_ext <- powerSim(mod_ext, fixed("pactotal",method="kr"),nsim=100,
                    progress=FALSE)

pwr.df <- data.frame(
groups = groups,
pwr_est = summary(pwr_ext)$mean,
pwr_li = summary(pwr_ext)$lower,
pwr_hi = summary(pwr_ext)$upper)

return(pwr.df)
  
}
```



```{r}
mgrp_sim_L2 <- function(groups){

# Assumes lmer object is available  
if (groups == 5)
  {mod_ext <- modp_sub}
else 
  {mod_ext <- extend(modp_sub, along="stnum", n=groups)}
  
pwr_ext <- powerSim(mod_ext, fixed("acres",method="kr"),nsim=100,
                    progress=FALSE)

pwr.df <- data.frame(
groups = groups,
pwr_est = summary(pwr_ext)$mean,
pwr_li = summary(pwr_ext)$lower,
pwr_hi = summary(pwr_ext)$upper)

return(pwr.df)
  
}
```

```{r}
mgrp_sim_CLI <- function(groups){

# Assumes lmer object is available
  
if (groups == 5)
  {mod_ext <- modp_sub}
else 
  {mod_ext <- extend(modp_sub, along="stnum", n=groups)}
  
pwr_ext <- powerSim(mod_ext, fixed("pactotal:acres",method="kr"),nsim=100,
                    progress=FALSE)

pwr.df <- data.frame(
groups = groups,
pwr_est = summary(pwr_ext)$mean,
pwr_li = summary(pwr_ext)$lower,
pwr_hi = summary(pwr_ext)$upper)

return(pwr.df)
  
}
```

## Preparing graph

### L1

```{r}
g <- as.list(seq(5,50,5))
pg_L1.df <- adply(g,1,mgrp_sim_L1)
```

```{r}
ggplot(pg_L1.df, aes(x=groups, y=pwr_est)) +
  geom_errorbar(aes(ymin=pwr_li, ymax=pwr_hi),
                color="grey25",
                size=.7,width=1.5) +
  geom_line() +
  geom_point(size=2) +
  scale_y_continuous(labels=percent, limits=c(0,1.05),breaks=c(seq(0,1,.2))) +
  geom_hline(yintercept=.8,linetype="dashed",color="grey30") +
  xlab("Groups") +
  ylab("Estimated Power\n") +
  labs(title="L1 - PacTotal") +
  theme_minimal() +
  theme(plot.title = element_text(hjust=.5))


```

### L2

```{r}
g <- as.list(seq(5,50,5))
pg_L2.df <- adply(g,1,mgrp_sim_L2)
```


```{r}
ggplot(pg_L2.df, aes(x=groups, y=pwr_est)) +
  geom_errorbar(aes(ymin=pwr_li, ymax=pwr_hi),
                color="grey25",
                size=.7,width=1.5) +
  geom_line() +
  geom_point(size=2) +
  scale_y_continuous(labels=percent, limits=c(0,1.05),breaks=c(seq(0,1,.2))) +
  geom_hline(yintercept=.8,linetype="dashed",color="grey30") +
  xlab("Groups") +
  ylab("Estimated Power\n") +
  labs(title="L2 - Acres") +
  theme_minimal() +
  theme(plot.title = element_text(hjust=.5))


```

### CLI

```{r}
g <- as.list(seq(5,50,5))
pg_CLI.df <- adply(g,1,mgrp_sim_CLI)
```

```{r}
ggplot(pg_CLI.df, aes(x=groups, y=pwr_est)) +
  geom_errorbar(aes(ymin=pwr_li, ymax=pwr_hi),
                color="grey25",
                size=.7,width=1.5) +
  geom_line() +
  geom_point(size=2) +
  scale_y_continuous(labels=percent, limits=c(0,1.05),breaks=c(seq(0,1,.2))) +
  geom_hline(yintercept=.8,linetype="dashed",color="grey30") +
  xlab("Groups") +
  ylab("Estimated Power\n") +
  labs(title="CLI - PacTotal by Acres") +
  theme_minimal() +
  theme(plot.title = element_text(hjust=.5))


```


## Increasing representatives within groups

The functions

```{r}
mrep_sim_L1 <- function(groups){

# Assumes lmer object is available  
if (groups == 5)
  {mod_ext <- modp_sub}
else 
  {mod_ext <- extend(modp_sub, within="stnum", n=groups)}
  
pwr_ext <- powerSim(mod_ext, fixed("pactotal",method="kr"),nsim=100,
                    progress=FALSE)

pwr.df <- data.frame(
groups = groups,
pwr_est = summary(pwr_ext)$mean,
pwr_li = summary(pwr_ext)$lower,
pwr_hi = summary(pwr_ext)$upper)

return(pwr.df)
  
}
```



```{r}
mrep_sim_L2 <- function(groups){

# Assumes lmer object is available  
if (groups == 5)
  {mod_ext <- modp_sub}
else 
  {mod_ext <- extend(modp_sub, within="stnum", n=groups)}
  
pwr_ext <- powerSim(mod_ext, fixed("acres",method="kr"),nsim=100,
                    progress=FALSE)

pwr.df <- data.frame(
groups = groups,
pwr_est = summary(pwr_ext)$mean,
pwr_li = summary(pwr_ext)$lower,
pwr_hi = summary(pwr_ext)$upper)

return(pwr.df)
  
}
```

```{r}
mrep_sim_CLI <- function(groups){

# Assumes lmer object is available
  
if (groups == 5)
  {mod_ext <- modp_sub}
else 
  {mod_ext <- extend(modp_sub, within="stnum", n=groups)}
  
pwr_ext <- powerSim(mod_ext, fixed("pactotal:acres",method="kr"),nsim=100,
                    progress=FALSE)

pwr.df <- data.frame(
groups = groups,
pwr_est = summary(pwr_ext)$mean,
pwr_li = summary(pwr_ext)$lower,
pwr_hi = summary(pwr_ext)$upper)

return(pwr.df)
  
}
```

## Preparing graphs for representatives

### L1

```{r}
g <- as.list(seq(5,50,5))
pr_L1.df <- adply(g,1,mrep_sim_L1)
```

```{r}
ggplot(pr_L1.df, aes(x=groups, y=pwr_est)) +
  geom_errorbar(aes(ymin=pwr_li, ymax=pwr_hi),
                color="grey25",
                size=.7,width=1.5) +
  geom_line() +
  geom_point(size=2) +
  scale_y_continuous(labels=percent, limits=c(0,1.05),breaks=c(seq(0,1,.2))) +
  geom_hline(yintercept=.8,linetype="dashed",color="grey30") +
  xlab("Reps within Groups") +
  ylab("Estimated Power\n") +
  labs(title="L1 - PacTotal") +
  theme_minimal() +
  theme(plot.title = element_text(hjust=.5))


```

### L2

```{r}
g <- as.list(seq(5,50,5))
pr_L2.df <- adply(g,1,mrep_sim_L2)
```


```{r}
ggplot(pr_L2.df, aes(x=groups, y=pwr_est)) +
  geom_errorbar(aes(ymin=pwr_li, ymax=pwr_hi),
                color="grey25",
                size=.7,width=1.5) +
  geom_line() +
  geom_point(size=2) +
  scale_y_continuous(labels=percent, limits=c(0,1.05),breaks=c(seq(0,1,.2))) +
  geom_hline(yintercept=.8,linetype="dashed",color="grey30") +
  xlab("Reps within Groups") +
  ylab("Estimated Power\n") +
  labs(title="L2 - Acres") +
  theme_minimal() +
  theme(plot.title = element_text(hjust=.5))


```

### CLI

```{r}
g <- as.list(seq(5,50,5))
pr_CLI.df <- adply(g,1,mrep_sim_CLI)
```

```{r}
ggplot(pr_CLI.df, aes(x=groups, y=pwr_est)) +
  geom_errorbar(aes(ymin=pwr_li, ymax=pwr_hi),
                color="grey25",
                size=.7,width=1.5) +
  geom_line() +
  geom_point(size=2) +
  scale_y_continuous(labels=percent, limits=c(0,1.05),breaks=c(seq(0,1,.2))) +
  geom_hline(yintercept=.8,linetype="dashed",color="grey30") +
  xlab("Reps within Groups") +
  ylab("Estimated Power\n") +
  labs(title="CLI - PacTotal by Acres") +
  theme_minimal() +
  theme(plot.title = element_text(hjust=.5))


```


### Old stuff
## Figuring things out

```{r}
x <- rep(1:10)
g <- c('a', 'b', 'c')

X <- expand.grid(x=x, g=g)

b <- c(2, -0.1) # fixed intercept and slope
V1 <- 0.5 # random intercept variance
V2 <- matrix(c(0.5,0.05,0.05,0.1), 2) # random intercept and slope variance-covariance matrix
s <- 1 # residual variance

```

This actually works, although printing the model object doesn't indicate
that the group numbers have changed.

```{r}



model1 <- makeLmer(y ~ x + (1|g), fixef=b, VarCorr=V1, sigma=s, data=X)
print(model1)

powerSim(model1, nsim=20)

model_grp <- extend(model1, along="g", n=15)
print(model_grp)

powerSim(model_grp, nsim=20)
```

## Based on actual model

Setup

```{r}
library(lme4)
library(LukeMLM)
data("tvprp")

tvsamp <- tvprp[tvprp$state %in% c("CA","FL","IL","NY","WI","MO","NC","IN","WV","LA"),]
```


```{r}
mod2 <- lmer(votepct ~ party + pactotal + acres + (party|state),data=tvprp,REML=FALSE)
summary(mod2)

```

Simple power. Default is first fixed effect.

```{r}
powerSim(mod2)
```

Can specify other fixed effects.

```{r}
powerSim(mod2, fixed("acres"))
```

Finding minimum power?

```{r}
powerSim(mod2,test=fixed("pactotal"),nsim=100)
pc2 <- powerCurve(mod2,test=fixed("pactotal"),along="state",nsim=100)
plot(pc2)
```
Not sure how to handle above.

Looking at number of groups for acres effect.

```{r}
powerSim(mod2,test=fixed("acres"),nsim=100)
mod3 <- extend(mod2,along="state",n=100)
pc3 <- powerCurve(mod3,test=fixed("acres"),along="state",nsim=100)
plot(pc3)


```

Now, it looks like the 'within' option is the key to doing level-1 sample size estimation.

```{r}
powerSim(mod2,test=fixed("pactotal"),nsim=100)
pc4 <- powerCurve(mod2,test=fixed("pactotal"),within="state",nsim=100)
print(pc4)
plot(pc4)
```

This should show that increasing sample size within groups will not help a level-2 predictor.

```{r}
pc5 <- powerCurve(mod2,test=fixed("acres"),within="state",nsim=100)
print(pc5)
plot(pc5)

```

Hmmm, try extending?

```{r}
mod6 <- extend(mod2,within="state",n=1000)
pc6 <- powerCurve(mod6,test=fixed("acres"),within="state",nsim=100)
print(pc6)
plot(pc6)

```
